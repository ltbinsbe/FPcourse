include "ParseGen.ag"
include "HS.ag"
include "Validate.ag"

module {AG.Main} {} {}
imports
{
import Data.List (groupBy, intercalate)
import Data.Char (toUpper, toLower)
import CCO.Component (Component, component)
}

-- The parse tree
data Root       | Root   grammar :: Grammar
data Grammar    | Grammar  ps    :: Productions
data Production | Production  nt :: Node         cs :: String    fs :: Nodes
data Node       | NT       ident :: String
                | T        ident :: String
                | BoolLit
                | IntLit

-- Tree print tree
data Document   | Document head  :: String  dts  :: DataTypes tms:: {[String]}
data DataType   | DataType    nt :: Node      ps :: Prods
data Prod       | Prod        nt :: Node      cs :: String     fs :: Nodes

type Productions = [ Production ]
type Prods       = [ Prod ]
type Nodes       = [ Node ]
type DataTypes   = [ DataType ]

deriving Grammar    : Show
deriving Production : Show
deriving Node       : Eq

attr Node  syn                   id :: String

sem Node  | NT      lhs.id  = @ident
          | T       lhs.id  = @ident
                    lhs.tms = [@ident]
          | BoolLit lhs.id  = "Bool"
          | IntLit  lhs.id  = "Int"



{
generate :: String -> Document -> IO ()
generate path (Document head dts tms) = do 
    lexer <- readFile "utils/Lexer.hs"
    writeFile (path ++ "Lexer.hs") lexer
    writeFile (path ++ "Data.hs") terminals
    writeFile (path ++ "Sem.ag") ag
    writeFile (path ++ "Parser.hs") parser
    writeFile (path ++ "Makefile") mk
    writeFile (path ++ "Main.hs") mf
      where
        mf        = unlines $
                        [ "module Main where"
                        , "import CCO.Component (ioWrap, component)"
                        , "import Parser (parser)"
                        , "import Sem"
                        , "import Control.Arrow ((>>>))"
                        , "main = ioWrap $ parser >>> component (\\tree -> return $ show tree)"
                        ]
        mk        = unlines $ 
                        [ "all :"
                        , "\tuuagc -Hdcfws --self Sem.ag"
                        , "\tghc --make Main.hs -o parser"
                        , "\trm *.hi *.o"
                        ]
        ag        = unlines $
                        [ "module{Sem} {} {}"       
                        ] ++ dtypes ++ sems ++ drvs
        nts       = [ nt | (DataType (NT nt) _) <- dts]
        drvs      = map (\t -> "deriving " ++ map toUpper t ++ " : Show") nts
        sems      = []
        dtypes    = hs_Syn_DataTypes wrapper
        terminals = 
            unlines  [ "module Data where"
                     , "terminals = [\"" ++ (intercalate "\",\"" tms) ++ "\"]"
                     ]
        parser = head ++ "\n" ++ unlines pLines
        pLines = plns_Syn_DataTypes wrapper
        wrapper= wrap_DataTypes (sem_DataTypes dts) Inh_DataTypes{}

docHeader r =  unlines  [ "module Parser where"
                        , "import Sem"
                        , "import Lexer"
                        , "import CCO.Component as C"
                        , "import CCO.Parsing (Parser(..))"
                        , "import Control.Applicative"
                        , "parser = C.parser lexer p" ++ (map toUpper r)
                        ]

}

