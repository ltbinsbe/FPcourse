module {Gen} {} {}
imports
{
import Data.List (groupBy, intercalate)
import Data.Char (toUpper, toLower)
import CCO.Component (Component, component)
}

data Root       | Root   grammar :: Grammar
data Grammar    | Grammar  ps    :: Productions
data Production | Production  nt :: Node         cs :: String    fs :: Nodes
data Node       | NT       ident :: String
                | T        ident :: String
                | BoolLit
                | IntLit

type Productions = [ Production ]
type Prods       = [ Prod ]
type Nodes       = [ Node ]
type DataTypes  = [ DataType ]

data Document   | Document head  :: String  dts  :: DataTypes tms:: {[String]}
data DataType   | DataType    nt :: Node      ps :: Prods
data Prod       | Prod        nt :: Node      cs :: String     fs :: Nodes

attr Root Grammar Productions Production
        syn prods use {(++)} {[]}   :: Prods
        syn errs use {(++)} {[]}    :: {[String]}
        syn tms use {(++)} {[]}     :: {[String]}
attr Nodes syn fs :: {[String]}
attr Node 
        syn id                      :: String
attr Nodes Node
        syn tms use {(++)} {[]}     :: {[String]}

sem Grammar    | Grammar 
                    lhs.prods = @ps.prods
sem Production | Production 
                    lhs.prods = 
                        if null @loc.errs 
                            then [Prod (NT @nt.id) @cs @fs.self] 
                            else []
                    loc.errs  = 
                        case @nt.self of
                            NT _ -> []
                            _    -> error "Terminal on LHS, check Parser"

sem Nodes | Cons    lhs.fs = (if hasType @hd.self then [typeName @hd.self] else []) ++ @tl.fs
          | Nil     lhs.fs = []
sem Node | NT       lhs.id = @ident
         | T        lhs.id = @ident
                    lhs.tms= [@ident]
         | BoolLit  lhs.id = "Bool"
         | IntLit   lhs.id = "Int"

attr Prods DataTypes
        syn plns    use {(++)} {[]} :: {[String]}
attr Prod DataType
        syn p                       :: String

sem DataTypes | Cons lhs.plns = @hd.p : @tl.plns
sem DataType  | DataType 
        loc.p    = show @nt.self ++ " = " ++ @loc.pCs
        loc.pCs  = intercalate " <|> " @ps.plns

sem Prods | Cons lhs.plns   = @hd.p : @tl.plns
sem Prod  | Prod lhs.p      = "(" ++ consParser @cs @fs.self ++ ")"


data DataTypes DataType Prods Prod
    syn hs use {(++)} {[]}  :: {[String]}
    
sem DataType | DataType lhs.hs = ["data " ++ (map toUpper @nt.id) ++ unlines @ps.hs]
sem Prod     | Prod     lhs.hs = ["| " ++ map toUpper @cs ++ "  " ++ (intercalate " " (map (\f -> map toLower f ++ " :: " ++ f) @fs.fs))]

{
validate :: Grammar -> IO (Maybe Document)
validate grammar = do 
                let wrapper = (wrap_Root (sem_Root $ Root grammar) Inh_Root{})
                let errors  = errs_Syn_Root     wrapper
                let prods   = prods_Syn_Root    wrapper
                let tms     = tms_Syn_Root      wrapper
                let dts     = map (\(p@(Prod nt _ _):pds) -> DataType nt (p:pds)) $ groupBy (\(Prod n1 _ _) (Prod n2 _ _) -> n1 == n2) prods
                let root    = (\(DataType (NT r) _) -> r) $ head dts 
                case errors of
                    []  -> return $ Just $ Document (docHeader root) dts tms
                    _   -> putStrLn (unlines errors) >> return Nothing
            
generate :: String -> Document -> IO ()
generate path (Document head dts tms) = do 
    lexer <- readFile "utils/Lexer.hs"
    writeFile (path ++ "Lexer.hs") lexer
    writeFile (path ++ "Data.hs") terminals
    writeFile (path ++ "Sem.ag") ag
    writeFile (path ++ "Parser.hs") parser
    writeFile (path ++ "Makefile") mk
    writeFile (path ++ "Main.hs") mf
      where
        mf        = unlines $
                        [ "module Main where"
                        , "import CCO.Component (ioWrap, component)"
                        , "import Parser (parser)"
                        , "import Sem"
                        , "import Control.Arrow ((>>>))"
                        , "main = ioWrap $ parser >>> component (\\tree -> return $ show tree)"
                        ]
        mk        = unlines $ 
                        [ "all :"
                        , "\tuuagc -Hdcfws --self Sem.ag"
                        , "\tghc --make Main.hs -o parser"
                        , "\trm *.hi *.o"
                        ]
        ag        = unlines $
                        [ "module{Sem} {} {}"       
                        ] ++ dtypes ++ sems ++ drvs
        nts       = [ nt | (DataType (NT nt) _) <- dts]
        drvs      = map (\t -> "deriving " ++ map toUpper t ++ " : Show") nts
        sems      = []
        dtypes    = hs_Syn_DataTypes wrapper
        terminals = 
            unlines  [ "module Data where"
                     , "terminals = [\"" ++ (intercalate "\",\"" tms) ++ "\"]"
                     ]
        parser = head ++ "\n" ++ unlines pLines
        pLines = plns_Syn_DataTypes wrapper
        wrapper= wrap_DataTypes (sem_DataTypes dts) Inh_DataTypes{}

docHeader r =  unlines  [ "module Parser where"
                        , "import Sem"
                        , "import Lexer"
                        , "import CCO.Component as C"
                        , "import CCO.Parsing (Parser(..))"
                        , "import Control.Applicative"
                        , "parser = C.parser lexer p" ++ (map toUpper r)
                        ]


consParser :: String -> Nodes -> String
consParser c fs = consName ++ app ++ fieldParser fs
    where   consName = map toUpper c
            app      = case head fs of
                        (T _) -> " <$ "
                        _     -> " <$> " 

hasType :: Node -> Bool
hasType (T _) = False
hasType _     = True

typeName :: Node -> String
typeName (NT nt) = map toUpper nt
typeName BoolLit = "Bool"
typeName IntLit  = "Int"

fieldParser :: Nodes -> String
fieldParser []      = ""
fieldParser [f]     = show f 
fieldParser (f:fs)  = show f ++ conc (head fs) ++ fieldParser fs
    where conc (T x)= " <* "
          conc _    = " <*> "

instance Show Node where
    show (NT nt)    = "p" ++ map toUpper nt
    show (T tm)     = "pTm \"" ++ tm ++ "\""
    show (BoolLit)  = "pBool"
    show (IntLit)   = "pInt"
}

deriving Grammar    : Show
deriving Production : Show
deriving T          : Show
deriving Ty         : Show
deriving Node       : Eq

