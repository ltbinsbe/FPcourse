        -- these f(ield)s contain the parts of the right hand side of a 
        -- production that have types (so no terminal symbols)
        -- they are used in constructor definitions
attr Nodes syn                   fs :: {[(String, String)]} 

sem Nodes | Cons    lhs.fs  = 
            (if hasType @hd.self then [typeName @hd.self] else []) ++ @tl.fs
          | Nil     lhs.fs  = []


data DataTypes DataType Productions Production
    -- the haskell to be generated for this datatype / constructor
    syn hs use {(++)} {[]}  :: {[String]}
    
sem DataType | DataType lhs.hs = 
    ["data " ++ @nt.id ++ unlines @ps.hs]
sem Production 
       | Production     lhs.hs = 
    ["| " ++ @cs ++ "  " ++ 
        (intercalate " " (map (\(f,t) -> f ++ " :: " ++ t) @fs.fs))]

{
hasType :: Node -> Bool
hasType (T _ _) = False
hasType (BR _)  = False
hasType _       = True

typeName :: Node -> (String, String)
typeName (NT nt nm q)     = (nm, typeQ q nt)
typeName (DigitLit nm q)  = (nm, typeQ q "Int")
typeName (BoolLit nm q)   = (nm, typeQ q "Bool")
typeName (IntLit nm q)    = (nm, typeQ q "Int")
typeName _                = error "ParseGen bug: errno 1"

typeQ Single   n = n
typeQ Optional n = "{Maybe " ++ n ++ "}"
typeQ _ n        = "{[" ++ n ++ "]}"
}
