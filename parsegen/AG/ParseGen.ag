attr Productions DataTypes
        -- the parsers for productions and non-terminals
        syn plns    use {(++)} {[]} :: {[String]}
attr Production DataType
        syn p                       :: String

sem DataTypes | Cons lhs.plns = @hd.p : @tl.plns
sem DataType  | DataType 
        loc.p    = showP @nt.self ++ " = " ++ @loc.pCs
        loc.pCs  = intercalate " <|> " @ps.plns

sem Productions | Cons lhs.plns     = @hd.p : @tl.plns
sem Production  | Production lhs.p  = "(" ++ consParser @cs @fs.self ++ ")"

{
consParser :: String -> Nodes -> String
consParser c fs = consName ++ app ++ fieldParser fs
    where   consName = c
            app      = case head fs of
                        (T _ _) -> " <$ "
                        _       -> " <$> " 
fieldParser :: Nodes -> String
fieldParser []      = ""
fieldParser [f]     = showP f 
fieldParser (f:fs)  = showP f ++ conc (head fs) ++ fieldParser fs
    where conc (T x _) = " <* "
          conc _       = " <*> "

showP n@(NT nt _ q)     = showQ q $ "p" ++ nt
showP n@(T tm q)        = showQ q $ "pTm \"" ++ tm ++ "\""
showP n@(BR q)          = showQ q $ "pBR"
showP n@(DigitLit _ q)  = showQ q $ "pDigit"
showP n@(BoolLit _ q)   = showQ q $ "pBool"
showP n@(IntLit _ q)    = showQ q $ "pInt"

showQ Single n     = n
showQ Many n       = "( many " ++ n ++ " )"
showQ Some n       = "( some " ++ n ++ " )"
showQ Optional n   = "( optional " ++ n ++ " )"

}
