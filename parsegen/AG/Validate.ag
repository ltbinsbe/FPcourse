attr Root Grammar
        -- the productions are required to for a document
        -- which contains datatypes (where productions are constructors)
        syn prods                   :: Productions
attr Root Grammar Productions Production
        -- collect errors in the grammar
        syn errs use {(++)} {[]}    :: {[String]}
        -- tms is required for the Lexer, they are printed in Data.hs
        syn tms use {(++)} {[]}     :: {[String]} 
attr Nodes Node
        syn tms use {(++)} {[]}     :: {[String]}

sem Grammar | Grammar lhs.prods = @ps.self
sem Node    | T         lhs.tms = [@ident]

{
validate :: Grammar -> IO (Maybe Document)
validate grammar = do 
    let wrapper = (wrap_Root (sem_Root $ Root grammar) Inh_Root{})
    let errors  = errs_Syn_Root     wrapper
    let prods   = prods_Syn_Root    wrapper
    let tms     = tms_Syn_Root      wrapper
    let dts     = map (\(p@(Production nt _ _):pds) -> DataType nt (p:pds)) $ 
                    groupBy (\(Production n1 _ _) (Production n2 _ _) -> 
                        n1 == n2) prods
    let root    = (\(DataType (NT r _ _) _) -> r) $ head dts 
    case errors of
        []  -> return $ Just $ Document (docHeader root) dts tms
        _   -> putStrLn (unlines errors) >> return Nothing
}
